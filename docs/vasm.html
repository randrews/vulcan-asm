<!DOCTYPE html>

<html>
<head>
  <title>../vasm.lua</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="locco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    <div id="jump_to">
  Jump To &hellip;
  <div id="jump_wrapper">
  <div id="jump_page">
  <a class="source" href="cpu.html">../cpu.lua</a>
  <a class="source" href="display.html">../display.lua</a>
  <a class="source" href="vasm.html">../vasm.lua</a>
  <a class="source" href="vasm_test.html">../vasm_test.lua</a>
  <a class="source" href="vemu.html">../vemu.lua</a>
  <a class="source" href="vemu_test.html">../vemu_test.lua</a>
    </div>
  </div>
</div>

    <table cellpadding="0" cellspacing="0">
      <thead>
        <tr>
          <th class="docs">
            <h1>
              ../vasm.lua
            </h1>
          </th>
          <th class="code">
          </th>
        </tr>
      </thead>
      <tbody>
<tr id="section-1">
<td class="docs">
  <div class="pilwrap">
    <a class="pilcrow" href="#section-1">&#182;</a>
  </div>
  
<h3>Purpose</h3>
<p>This is going to be an emulator / development tool for the Vulcan microcomputer.
It will be able to parse assembly files and run them, including an emulation of the
video display and keyboard in a window.</p>


</td>
<td class="code">
  <div class="highlight"><pre>
</pre></div>
</td>
</tr><tr id="section-2">
<td class="docs">
  <div class="pilwrap">
    <a class="pilcrow" href="#section-2">&#182;</a>
  </div>
  
<h3>Dependencies</h3>
<p>To parse Vulcan assembly, we'll need a parser library, so, LPeg:</p>


</td>
<td class="code">
  <div class="highlight"><pre>lpeg = <span class="nt">require</span>(<span class="s">'lpeg'</span>)
</pre></div>
</td>
</tr><tr id="section-3">
<td class="docs">
  <div class="pilwrap">
    <a class="pilcrow" href="#section-3">&#182;</a>
  </div>
  
<h1>Utility functions</h1>


</td>
<td class="code">
  <div class="highlight"><pre>
</pre></div>
</td>
</tr><tr id="section-4">
<td class="docs">
  <div class="pilwrap">
    <a class="pilcrow" href="#section-4">&#182;</a>
  </div>
  
<p>Map a function across a table</p>


</td>
<td class="code">
  <div class="highlight"><pre><span class="k">function</span> <span class="nf">table:map</span>(fn)
    <span class="k">local</span> t = {}
    <span class="k">for</span> _, v <span class="k">in</span> <span class="nt">ipairs</span>(self) <span class="k">do</span>
        table.insert(t, fn(v))
    <span class="k">end</span>
    <span class="k">return</span> t
<span class="k">end</span>
</pre></div>
</td>
</tr><tr id="section-5">
<td class="docs">
  <div class="pilwrap">
    <a class="pilcrow" href="#section-5">&#182;</a>
  </div>
  
<p>Reduce a table with a function</p>


</td>
<td class="code">
  <div class="highlight"><pre><span class="k">function</span> <span class="nf">table:reduce</span>(fn, sum)
    <span class="k">local</span> start_idx = 1
    <span class="k">if</span> <span class="o">not</span> sum <span class="k">then</span>
        start_idx = 2
        sum = self[1]
    <span class="k">end</span>

    <span class="k">for</span> i = start_idx, #self <span class="k">do</span>
        sum = fn(sum, self[i])
    <span class="k">end</span>

    <span class="k">return</span> sum
<span class="k">end</span>
</pre></div>
</td>
</tr><tr id="section-6">
<td class="docs">
  <div class="pilwrap">
    <a class="pilcrow" href="#section-6">&#182;</a>
  </div>
  
<h1>Assembly parser</h1>


</td>
<td class="code">
  <div class="highlight"><pre>
</pre></div>
</td>
</tr><tr id="section-7">
<td class="docs">
  <div class="pilwrap">
    <a class="pilcrow" href="#section-7">&#182;</a>
  </div>
  
<p>Put this all in a function so we don't have a bunch of
stuff in the namespace</p>


</td>
<td class="code">
  <div class="highlight"><pre><span class="k">function</span> <span class="nf">statement_pattern</span>()
</pre></div>
</td>
</tr><tr id="section-8">
<td class="docs">
  <div class="pilwrap">
    <a class="pilcrow" href="#section-8">&#182;</a>
  </div>
  
<p>First, we want to define some basic patterns. <code>space</code> will be any sequence of whitespace,
so we can ignore it easily:</p>


</td>
<td class="code">
  <div class="highlight"><pre>    <span class="k">local</span> space = lpeg.S(<span class="s">" \t"</span>)^0
</pre></div>
</td>
</tr><tr id="section-9">
<td class="docs">
  <div class="pilwrap">
    <a class="pilcrow" href="#section-9">&#182;</a>
  </div>
  
<p>A comment will start with a semicolon and go to the end of the line. Actually everything is parsed
line by line, so anything that starts with a semicolon is a comment:</p>


</td>
<td class="code">
  <div class="highlight"><pre>    <span class="k">local</span> comment = lpeg.P(<span class="s">';'</span>) * lpeg.P(1)^0
</pre></div>
</td>
</tr><tr id="section-10">
<td class="docs">
  <div class="pilwrap">
    <a class="pilcrow" href="#section-10">&#182;</a>
  </div>
  
<p>Numbers are more complicated. We'll support three formats:</p>

<ul>
    <li>Decimal numbers like 42</li>
    <li>Hexadecimal like 0x2a</li>
    <li>Binary like 0b00101010</li>
    <li>Decimal zero needs its own pattern: it's not a decimal because
    it starts with a 0, but it has to be matched after hex and bin
    because otherwise any "0x" will parse as "decimal 0 followed
    by unparseable x"</li>
</ul>


</td>
<td class="code">
  <div class="highlight"><pre>    <span class="k">local</span> dec_number = (lpeg.R(<span class="s">'19'</span>) * lpeg.R(<span class="s">'09'</span>)^0) / <span class="nt">tonumber</span>
    <span class="k">local</span> hex_number = lpeg.P(<span class="s">'0x'</span>) * lpeg.C(lpeg.R(<span class="s">'09'</span>,<span class="s">'af'</span>,<span class="s">'AF'</span>)^1) / <span class="k">function</span>(s) <span class="k">return</span> <span class="nt">tonumber</span>(s, 16) <span class="k">end</span>
    <span class="k">local</span> bin_number = lpeg.P(<span class="s">'0b'</span>) * lpeg.C(lpeg.S(<span class="s">'01'</span>)^1) / <span class="k">function</span>(s) <span class="k">return</span> <span class="nt">tonumber</span>(s, 2) <span class="k">end</span>
    <span class="k">local</span> dec_zero = lpeg.P(<span class="s">'0'</span>) / <span class="nt">tonumber</span>
    <span class="k">local</span> number = dec_number + hex_number + bin_number + dec_zero
</pre></div>
</td>
</tr><tr id="section-11">
<td class="docs">
  <div class="pilwrap">
    <a class="pilcrow" href="#section-11">&#182;</a>
  </div>
  
<p>A label can be any sequence of C-identifier-y characters, as long as it doesn't start with
a digit:</p>


</td>
<td class="code">
  <div class="highlight"><pre>    <span class="k">local</span> label_char = (lpeg.R(<span class="s">'az'</span>, <span class="s">'AZ'</span>) + lpeg.S(<span class="s">'_$'</span>))
    <span class="k">local</span> label = lpeg.C(label_char * (label_char + lpeg.R(<span class="s">'09'</span>))^0)
</pre></div>
</td>
</tr><tr id="section-12">
<td class="docs">
  <div class="pilwrap">
    <a class="pilcrow" href="#section-12">&#182;</a>
  </div>
  
<p>To make relative jumps easier, we'll also allow an '@' at the start of a label, and interpret
that as meaning "relative to the first byte of this instruction:"</p>


</td>
<td class="code">
  <div class="highlight"><pre>    <span class="k">local</span> relative_label = lpeg.C(lpeg.P(<span class="s">'@'</span>) * label_char * (label_char + lpeg.R(<span class="s">'09'</span>))^0)
</pre></div>
</td>
</tr><tr id="section-13">
<td class="docs">
  <div class="pilwrap">
    <a class="pilcrow" href="#section-13">&#182;</a>
  </div>
  
<h2>Opcodes</h2>
<p>An opcode is any one of several possible strings:</p>


</td>
<td class="code">
  <div class="highlight"><pre>    <span class="k">local</span> opcodes = {
        <span class="s">'push'</span>, <span class="s">'nop'</span>, <span class="s">'hlt'</span>, <span class="s">'pop'</span>, <span class="c">-- Basic instructions
</span>        <span class="s">'dup'</span>, <span class="s">'2dup'</span>, <span class="s">'swap'</span>, <span class="s">'pick'</span>, <span class="s">'height'</span>, <span class="c">-- Stack instructions
</span>        <span class="s">'add'</span>, <span class="s">'sub'</span>, <span class="s">'mul'</span>, <span class="s">'div'</span>, <span class="s">'mod'</span>, <span class="s">'rand'</span>, <span class="c">-- Arithmetic instructions
</span>        <span class="s">'and'</span>, <span class="s">'or'</span>, <span class="s">'xor'</span>, <span class="s">'not'</span>, <span class="s">'lshift'</span>, <span class="s">'rshift'</span>, <span class="s">'arshift'</span>, <span class="c">-- Logic instructions
</span>        <span class="s">'jmpr'</span>, <span class="s">'jmp'</span>, <span class="s">'call'</span>, <span class="s">'ret'</span>, <span class="s">'brz'</span>, <span class="s">'brnz'</span>, <span class="s">'brgt'</span>, <span class="s">'brlt'</span>, <span class="c">-- Branching and jumping
</span>        <span class="s">'load24'</span>, <span class="s">'load16'</span>, <span class="s">'load'</span>, <span class="c">-- Loading from memory
</span>        <span class="s">'store24'</span>, <span class="s">'store16'</span>, <span class="s">'store'</span>, <span class="c">-- Storing to memory
</span>        <span class="s">'inton'</span>, <span class="s">'intoff'</span>, <span class="s">'setiv'</span>, <span class="c">-- Interrupt handling
</span>        <span class="s">'frame'</span>, <span class="s">'local'</span>, <span class="s">'setlocal'</span> <span class="c">-- Stack frame variables
</span>    }
</pre></div>
</td>
</tr><tr id="section-14">
<td class="docs">
  <div class="pilwrap">
    <a class="pilcrow" href="#section-14">&#182;</a>
  </div>
  
<p>Combine the opcodes into one pattern:</p>


</td>
<td class="code">
  <div class="highlight"><pre>    <span class="k">local</span> opcode = lpeg.C(
        table.reduce(
            table.map(opcodes, lpeg.P),
            <span class="k">function</span>(a, b)
                <span class="k">return</span> a+b
            <span class="k">end</span>
    ))
</pre></div>
</td>
</tr><tr id="section-15">
<td class="docs">
  <div class="pilwrap">
    <a class="pilcrow" href="#section-15">&#182;</a>
  </div>
  
<h2>Directives</h2>
<p>The assembler will support some directives:</p>

<ul>
    <li>.org to set the current address</li>
    <li>.db to embed some data</li>
    <li>.equ to define some constants</li>
</ul>


</td>
<td class="code">
  <div class="highlight"><pre>    <span class="k">local</span> directive = lpeg.C(lpeg.P(<span class="s">'.org'</span>) + lpeg.P(<span class="s">'.db'</span>) + lpeg.P(<span class="s">'.equ'</span>))
</pre></div>
</td>
</tr><tr id="section-16">
<td class="docs">
  <div class="pilwrap">
    <a class="pilcrow" href="#section-16">&#182;</a>
  </div>
  
<p>The .equ directive isn't much use without the ability to have expressions based on
symbols, so, a quick arithmetic expression parser:</p>


</td>
<td class="code">
  <div class="highlight"><pre>    <span class="k">local</span> expr = lpeg.P{
        <span class="s">'EXPR'</span>;
        EXPR = lpeg.Ct( lpeg.Cc(<span class="s">'expr'</span>) * lpeg.V(<span class="s">'TERM'</span>) * (lpeg.C( lpeg.S(<span class="s">'+-'</span>) ) * lpeg.V(<span class="s">'TERM'</span>))^0 ),
        TERM = lpeg.Ct( lpeg.Cc(<span class="s">'term'</span>) * lpeg.V(<span class="s">'FACT'</span>) * (lpeg.C( lpeg.S(<span class="s">'/*&#37;'</span>) ) * lpeg.V(<span class="s">'FACT'</span>))^0 ),
        FACT = (space * <span class="s">'('</span> * lpeg.V(<span class="s">'EXPR'</span>) * <span class="s">')'</span>) + (space * (number + relative_label + label) * space)
    }
</pre></div>
</td>
</tr><tr id="section-17">
<td class="docs">
  <div class="pilwrap">
    <a class="pilcrow" href="#section-17">&#182;</a>
  </div>
  
<p>Likewise, .db would get tedious quick without a string syntax, so, let's define one of those. An escape
sequence is a backslash followed by certain other characters:</p>


</td>
<td class="code">
  <div class="highlight"><pre>    <span class="k">local</span> escape = lpeg.C(lpeg.P(<span class="s">'\\'</span>) * lpeg.S(<span class="s">'trn0"\\'</span>))
</pre></div>
</td>
</tr><tr id="section-18">
<td class="docs">
  <div class="pilwrap">
    <a class="pilcrow" href="#section-18">&#182;</a>
  </div>
  
<p>And a string is a quoted sequence of escapes or other characters:</p>


</td>
<td class="code">
  <div class="highlight"><pre>    <span class="k">local</span> string_pattern = lpeg.Ct(lpeg.Cc(<span class="s">'string'</span>) * lpeg.P(<span class="s">'"'</span>) * lpeg.Ct((lpeg.C(lpeg.P(1)-lpeg.S(<span class="s">'"\\'</span>)) + escape)^1) * <span class="s">'"'</span>)
</pre></div>
</td>
</tr><tr id="section-19">
<td class="docs">
  <div class="pilwrap">
    <a class="pilcrow" href="#section-19">&#182;</a>
  </div>
  
<h2>Parsing a line</h2>
<p>Normally an assembly line will be a sequence of "label, opcode, argument, comment."
However, most of these elements are optional. An opcode is only required if an
argument exists. Comments are parsed but don't capture anything.</p>


</td>
<td class="code">
  <div class="highlight"><pre>
</pre></div>
</td>
</tr><tr id="section-20">
<td class="docs">
  <div class="pilwrap">
    <a class="pilcrow" href="#section-20">&#182;</a>
  </div>
  
<p>Some sub-patterns for the portions of a line:</p>


</td>
<td class="code">
  <div class="highlight"><pre>    <span class="k">local</span> label_group = lpeg.Cc(<span class="s">'label'</span>) * label * <span class="s">':'</span>
    <span class="k">local</span> argument_group = lpeg.Cc(<span class="s">'argument'</span>) * (expr + string_pattern)
    <span class="k">local</span> comment_group = comment
</pre></div>
</td>
</tr><tr id="section-21">
<td class="docs">
  <div class="pilwrap">
    <a class="pilcrow" href="#section-21">&#182;</a>
  </div>
  
<p>An opcode might be an actual opcode, or a directive</p>


</td>
<td class="code">
  <div class="highlight"><pre>    <span class="k">local</span> opcode_group = lpeg.Cc(<span class="s">'opcode'</span>) * opcode + lpeg.Cc(<span class="s">'directive'</span>) * directive
    <span class="k">local</span> instruction_group = opcode_group * space * argument_group^-1
</pre></div>
</td>
</tr><tr id="section-22">
<td class="docs">
  <div class="pilwrap">
    <a class="pilcrow" href="#section-22">&#182;</a>
  </div>
  
<p>Finally the entire pattern for an assembly line:</p>


</td>
<td class="code">
  <div class="highlight"><pre>    <span class="k">return</span> lpeg.Ct(label_group^-1 * space * instruction_group^-1 * space * comment_group^-1 * lpeg.P(-1))
<span class="k">end</span>

statement = statement_pattern()
</pre></div>
</td>
</tr><tr id="section-23">
<td class="docs">
  <div class="pilwrap">
    <a class="pilcrow" href="#section-23">&#182;</a>
  </div>
  
<h1>Assembler</h1>


</td>
<td class="code">
  <div class="highlight"><pre>
</pre></div>
</td>
</tr><tr id="section-24">
<td class="docs">
  <div class="pilwrap">
    <a class="pilcrow" href="#section-24">&#182;</a>
  </div>
  
<h2>First pass</h2>
<p>Assembly parser. This will take in an iterator from which we can load lines of assembly, and return a
list of parsed lines, but with expressions un-evaluated.</p>

<p>The main goal here is to strip out semantically blank lines (comments, whitespace, blanks) and return
a list of parsed instructions we can then work with.</p>

<ul>
    <li>If we can't parse a line, throw an error</li>
    <li>If it parsed to an empty list (because it's just whitespace), skip it</li>
</ul>

<p>Otherwise, we have a line like: <code>{'label', 'foo', 'opcode', 'add'}</code>. We want to convert that to a more
convenient format of <code>{label='foo', opcode='add'}</code>. We're also going to store in each object the line
number from the original iterator that it represents, to make giving error messages later on possible.</p>

<p>Then, there are three errors that are easy to figure out here, so we'll catch them:</p>

<ul>
    <li>A string argument can't go on anything except a .db directive, so we'll error on that.</li>
    <li>A .equ directive doesn't make sense without a label to define the value of and a value to assign to
    it, so we'll error on that too.</li>
    <li>A .org doesn't make sense without an argument, so that will also be an error.</li>
</ul>


</td>
<td class="code">
  <div class="highlight"><pre><span class="k">function</span> <span class="nf">parse_assembly</span>(iterator)
    <span class="k">local</span> lines = {} <span class="c">-- This will store the eventual output
</span>    <span class="k">local</span> line_num = 1 <span class="c">-- A count of the line number
</span>
    <span class="k">for</span> line <span class="k">in</span> iterator <span class="k">do</span>
        <span class="k">local</span> ast = statement:match(line)

        <span class="k">if</span> ast == <span class="k">nil</span> <span class="k">then</span>
            <span class="nt">error</span>(<span class="s">'Parse error on line '</span> .. line_num .. <span class="s">': '</span> .. string.format(<span class="s">'&#37;q'</span>, line))
        <span class="k">end</span>

        <span class="k">if</span> #ast &gt; 0 <span class="k">then</span>
            <span class="k">local</span> obj = { line=line_num }
            <span class="k">for</span> n = 1, #ast, 2 <span class="k">do</span>
                obj[ast[n]] = ast[n+1]
            <span class="k">end</span>

            <span class="k">if</span> obj.argument <span class="o">and</span> obj.argument[1] == <span class="s">'string'</span> <span class="o">and</span> obj.directive ~= <span class="s">'.db'</span> <span class="k">then</span>
                <span class="nt">error</span>(<span class="s">'String argument outside .db directive on line '</span> .. line_num)
            <span class="k">end</span>

            <span class="k">if</span> obj.directive == <span class="s">'.equ'</span> <span class="o">and</span> (obj.argument == <span class="k">nil</span> <span class="o">or</span> obj.label == <span class="k">nil</span>) <span class="k">then</span>
                <span class="nt">error</span>(<span class="s">'.equ directive missing label or argument on line'</span> .. line_num)
            <span class="k">end</span>

            <span class="k">if</span> obj.directive == <span class="s">'.org'</span> <span class="o">and</span> obj.argument == <span class="k">nil</span> <span class="k">then</span>
                <span class="nt">error</span>(<span class="s">'.org directive missing argument on line '</span> .. line_num)
            <span class="k">end</span>

            table.insert(lines, obj)
        <span class="k">end</span>

        line_num = line_num + 1
    <span class="k">end</span>

    <span class="k">return</span> lines
<span class="k">end</span>
</pre></div>
</td>
</tr><tr id="section-25">
<td class="docs">
  <div class="pilwrap">
    <a class="pilcrow" href="#section-25">&#182;</a>
  </div>
  
<h2>Evaluating expressions</h2>
<p>Now that we have a parsed file, that file has a bunch of numeric symbols in it: labels,
.equ directives, that sort of thing. We need to resolve all of those to constant values
before we can generate code. So, first part of that is being able to evaluate expressions.</p>

<p>This evaluates an expression in the context of a symbol table, and returns either what the
expression evaluates to (a number) or throws an error (if it references a symbol not in
the given symbol table).</p>

<p>It's a depth-first recursive traversal of the expression AST:</p>

<ul>
    <li>If the node is a number, then it returns that number.</li>
    <li>If the node is a string, it tries to look it up in the symbol table or explodes.</li>
    <li>If the node is a relative label, it tries to look it up in the symbol table, and then
    subtracts a given start<em>address. If start</em>address is nil (as when we're solving .equs)
    then it errors.</li>
    <li>If the node is an expr or term, then it evaluates the children: the children are a
    sequence of evaluate-able nodes separated by operators. So first evaluate the left-most
    child, then use the operator to combine it with the following one, and so on.</li>
    <li>If the node is a parsed string (table with the first element being 'string'), it
    turns the second element into an array of bytes (parsing out escape sequences) and returns it.</li>
</ul>

<p>This works because the parser handles all the order-of-operations stuff in parsing, so
we don't need to care what actual type of node it is, expr or term.</p>

<p>One tricky point is that we call <code>math.floor</code> when dividing, because Lua has all floating-
point math but Vulcan only has fixed-point, truncating division.</p>


</td>
<td class="code">
  <div class="highlight"><pre><span class="k">function</span> <span class="nf">evaluate</span>(expr, symbols, start_address)
    <span class="k">if</span> <span class="nt">type</span>(expr) == <span class="s">'number'</span> <span class="k">then</span>
        <span class="k">return</span> expr
    <span class="k">elseif</span> <span class="nt">type</span>(expr) == <span class="s">'string'</span> <span class="k">then</span>
        <span class="k">if</span> expr:sub(1,1) == <span class="s">'@'</span> <span class="k">then</span>
            <span class="k">if</span> <span class="o">not</span> start_address <span class="k">then</span> <span class="nt">error</span>(<span class="s">'Cannot resolve relative label'</span>) <span class="k">end</span>
            <span class="k">local</span> label_name = expr:sub(2)
            <span class="k">if</span> symbols[label_name] <span class="k">then</span> <span class="k">return</span> symbols[label_name] - start_address
            <span class="k">else</span> <span class="nt">error</span>(<span class="s">'Symbol not defined: '</span> .. label_name) <span class="k">end</span>
        <span class="k">elseif</span> symbols[expr] <span class="k">then</span> <span class="k">return</span> symbols[expr]
        <span class="k">else</span> <span class="nt">error</span>(<span class="s">'Symbol not defined: '</span> .. expr) <span class="k">end</span>
    <span class="k">elseif</span> expr[1] == <span class="s">'expr'</span> <span class="o">or</span> expr[1] == <span class="s">'term'</span> <span class="k">then</span>
        <span class="k">local</span> val = evaluate(expr[2], symbols, start_address)

        <span class="k">for</span> i = 3, #expr, 2 <span class="k">do</span>
            <span class="k">local</span> operator = expr[i]
            <span class="k">local</span> rhs = evaluate(expr[i+1], symbols, start_address)
            <span class="k">if</span> operator == <span class="s">'+'</span> <span class="k">then</span>
                val = val + rhs
            <span class="k">elseif</span> operator == <span class="s">'-'</span> <span class="k">then</span>
                val = val - rhs
            <span class="k">elseif</span> operator == <span class="s">'*'</span> <span class="k">then</span>
                val = val * rhs
            <span class="k">elseif</span> operator == <span class="s">'/'</span> <span class="k">then</span>
                val = math.floor(val / rhs)
            <span class="k">elseif</span> operator == <span class="s">'&#37;'</span> <span class="k">then</span>
                val = val &#37; rhs
            <span class="k">end</span>
        <span class="k">end</span>
        <span class="k">return</span> val
    <span class="k">elseif</span> expr[1] == <span class="s">'string'</span> <span class="k">then</span>
        <span class="k">local</span> string_bytes = {}
        <span class="k">for</span> _,ch <span class="k">in</span> <span class="nt">ipairs</span>(expr[2]) <span class="k">do</span>
            <span class="k">if</span> ch:sub(1,1) == <span class="s">'\\'</span> <span class="k">then</span>
                <span class="k">local</span> escaped = ch:sub(2,2)
                <span class="k">if</span> escaped == <span class="s">'t'</span> <span class="k">then</span> table.insert(string_bytes, string.byte(<span class="s">'\t'</span>)) <span class="k">end</span>
                <span class="k">if</span> escaped == <span class="s">'r'</span> <span class="k">then</span> table.insert(string_bytes, string.byte(<span class="s">'\r'</span>)) <span class="k">end</span>
                <span class="k">if</span> escaped == <span class="s">'n'</span> <span class="k">then</span> table.insert(string_bytes, string.byte(<span class="s">'\n'</span>)) <span class="k">end</span>
                <span class="k">if</span> escaped == <span class="s">'0'</span> <span class="k">then</span> table.insert(string_bytes, string.byte(<span class="s">'\0'</span>)) <span class="k">end</span>
                <span class="k">if</span> escaped == <span class="s">'"'</span> <span class="k">then</span> table.insert(string_bytes, string.byte(<span class="s">'"'</span>)) <span class="k">end</span>
                <span class="k">if</span> escaped == <span class="s">'\\'</span> <span class="k">then</span> table.insert(string_bytes, string.byte(<span class="s">'\\'</span>)) <span class="k">end</span>
            <span class="k">else</span>
                table.insert(string_bytes, string.byte(ch))
            <span class="k">end</span>
        <span class="k">end</span>
        <span class="k">return</span> string_bytes
    <span class="k">else</span>
        <span class="nt">error</span>(<span class="s">'Unrecognized argument: type "'</span> .. <span class="nt">type</span>(expr) .. <span class="s">'"'</span>)
    <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</td>
</tr><tr id="section-26">
<td class="docs">
  <div class="pilwrap">
    <a class="pilcrow" href="#section-26">&#182;</a>
  </div>
  
<h2>Second pass</h2>
<p>This will solve all the .equ directives and return a symbol table of them.
.equ directives must be able to be solved in order, that is, in terms of
only preceding .equ directives. Anything else is an error.</p>


</td>
<td class="code">
  <div class="highlight"><pre><span class="k">function</span> <span class="nf">solve_equs</span>(lines)
    <span class="k">local</span> symbols = {}

    <span class="k">for</span> _, line <span class="k">in</span> <span class="nt">ipairs</span>(lines) <span class="k">do</span>
        <span class="k">if</span> line.directive == <span class="s">'.equ'</span> <span class="k">then</span>
            <span class="k">local</span> success, ret = <span class="nt">pcall</span>(evaluate, line.argument, symbols)
            <span class="k">if</span> success <span class="k">then</span> symbols[line.label] = ret
            <span class="k">else</span> <span class="nt">error</span>(<span class="s">'Cannot resolve .equ on line '</span> .. line.line .. <span class="s">': '</span> .. ret) <span class="k">end</span>
        <span class="k">end</span>
    <span class="k">end</span>

    <span class="k">return</span> symbols
<span class="k">end</span>
</pre></div>
</td>
</tr><tr id="section-27">
<td class="docs">
  <div class="pilwrap">
    <a class="pilcrow" href="#section-27">&#182;</a>
  </div>
  
<h2>Third pass</h2>
<p>We need to figure out the instruction lengths. We'll do this naively; if we can't
immediately tell that an instruction needs only a 0/1/2 byte argument (because it's
a constant, or a .equ that we've solved, or something) then we'll assume it's a
full 24-bit argument.</p>

<ul>
    <li>Lines that don't represent output (.equ, .org, etc) have length 0</li>
    <li>.db directives are either strings (set aside the length of the string), or
    numbers (set aside three bytes. If it's shorter than that it still may be a variable,
    which might grow to be larger).</li>
    <li>Opcodes with no argument are 1 byte long.</li>
    <li>Opcodes with an argument, if that argument is a constant or decidable solely with
    what we know right now (.equs), are however long that argument is. If we don't
    know right now (based on a label, say) then we'll set aside the full 3 bytes (so it's
    4 bytes long, with the instruction byte).</li>
</ul>


</td>
<td class="code">
  <div class="highlight"><pre><span class="k">function</span> <span class="nf">measure_instructions</span>(lines, symbols)
    <span class="k">for</span> _, line <span class="k">in</span> <span class="nt">ipairs</span>(lines) <span class="k">do</span>
        <span class="k">if</span> <span class="o">not</span>(line.opcode <span class="o">or</span> line.directive == <span class="s">'.db'</span>) <span class="k">then</span>
            line.length = 0
        <span class="k">elseif</span> line.directive == <span class="s">'.db'</span> <span class="k">then</span>
            <span class="k">if</span> line.argument[1] == <span class="s">'string'</span> <span class="k">then</span>
                line.length = #(line.argument[2])
            <span class="k">else</span>
                line.length = 3
            <span class="k">end</span>
        <span class="k">elseif</span> line.opcode <span class="k">then</span>
            <span class="k">if</span> <span class="o">not</span> line.argument <span class="k">then</span>
                line.length = 1
            <span class="k">else</span>
                <span class="k">local</span> success, val = <span class="nt">pcall</span>(evaluate, line.argument, symbols)
                <span class="k">if</span> <span class="o">not</span> success <span class="k">then</span> line.length = 4
                <span class="k">else</span>
                    <span class="k">if</span> val &lt; 256 <span class="k">then</span> line.length = 2
                    <span class="k">elseif</span> val &lt; 65536 <span class="k">then</span> line.length = 3
                    <span class="k">else</span> line.length = 4 <span class="k">end</span>
                <span class="k">end</span>
            <span class="k">end</span>
        <span class="k">end</span>
    <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</td>
</tr><tr id="section-28">
<td class="docs">
  <div class="pilwrap">
    <a class="pilcrow" href="#section-28">&#182;</a>
  </div>
  
<h2>Fourth pass</h2>
<p>Time to start placing labels. The tricky part here is the .org directives, which can have
expressions as their arguments. We'll compromise a little bit and say that a .org directive
can only refer to labels that precede it, so, you can use .orgs to generate (say) a jump table
but still make it easy for me to figure out what refers to what.</p>

<p>We'll have an <code>address</code> variable and go through the lines, adding each one's length (calculated
in the third pass) to it. If it has a label, we'll add that label's new value to <code>symbols</code>.</p>

<p>But, we'll skip labels that come before .equs: that would make every .equ set to its address,
rather than the argument.</p>

<p>For code generation, we also need to have the start and end addresses, so we'll take this
opportunity to calculate them and store them as <code>$start</code> and <code>$end</code> in the symbol table.</p>

<p>This means that this function will alter <code>lines</code>, by adding an <code>address</code> key to each one,
and <code>symbols</code>, by adding all the labels' addresses to it. It might also throw an error, if
it encounters a .org that refers to something it shouldn't.</p>


</td>
<td class="code">
  <div class="highlight"><pre><span class="k">function</span> <span class="nf">place_labels</span>(lines, symbols)
    <span class="k">local</span> address = 0
    <span class="k">local</span> start_addr = math.maxinteger
    <span class="k">local</span> end_addr = 0

    <span class="k">for</span> _, line <span class="k">in</span> <span class="nt">ipairs</span>(lines) <span class="k">do</span>
        <span class="k">if</span> line.directive == <span class="s">'.org'</span> <span class="k">then</span>
            <span class="k">local</span> success, ret = <span class="nt">pcall</span>(evaluate, line.argument, symbols)
            <span class="k">if</span> success <span class="k">then</span>
                address = ret
            <span class="k">else</span>
                <span class="nt">error</span>(<span class="s">'Unable to resolve .org on line '</span> .. line.line .. <span class="s">': '</span> .. ret)
            <span class="k">end</span>
        <span class="k">end</span>

        start_addr = math.min(start_addr, address)
        end_addr = math.max(end_addr, address + line.length - 1)

        line.address = address
        address = address + line.length

        <span class="k">if</span> line.label <span class="o">and</span> line.directive ~= <span class="s">'.equ'</span> <span class="k">then</span>
            symbols[line.label] = line.address
        <span class="k">end</span>
    <span class="k">end</span>

    symbols[<span class="s">'$start'</span>] = start_addr
    symbols[<span class="s">'$end'</span>] = end_addr
<span class="k">end</span>
</pre></div>
</td>
</tr><tr id="section-29">
<td class="docs">
  <div class="pilwrap">
    <a class="pilcrow" href="#section-29">&#182;</a>
  </div>
  
<h2>Fifth pass</h2>
<p>At this point we have everything we need to calculate the arguments, so we'll do that.
This will take the array of lines and map of symbols, and iterate through each line.
If the line has an argument, evaluate it based on the symbol table, and change it to
a number.</p>

<p>This can, of course, throw an error if </p>


</td>
<td class="code">
  <div class="highlight"><pre><span class="k">function</span> <span class="nf">calculate_args</span>(lines, symbols)
    <span class="k">for</span> _, line <span class="k">in</span> <span class="nt">ipairs</span>(lines) <span class="k">do</span>
        <span class="k">if</span> line.argument <span class="k">then</span>
            <span class="k">local</span> success, ret = <span class="nt">pcall</span>(evaluate, line.argument, symbols, line.address)
            <span class="k">if</span> success <span class="k">then</span>
                line.argument = ret
            <span class="k">else</span>
                <span class="nt">error</span>(<span class="s">'Unable to evaluate argument on line '</span> .. line.line .. <span class="s">': '</span> .. ret)
            <span class="k">end</span>
        <span class="k">end</span>
    <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</td>
</tr><tr id="section-30">
<td class="docs">
  <div class="pilwrap">
    <a class="pilcrow" href="#section-30">&#182;</a>
  </div>
  
<h2>Code generation</h2>
<p>At this point all lines have addresses and lengths, and all arguments are reduced to
numeric constants. It's time to generate code. This function takes the fully-resolved
<code>lines</code> array, start and end addresses, and returns an array of bytes, as numbers,
between 0 and 255.</p>

<p>The array of bytes will start at index 0, regardless of what the start address is. So,
if you pass in a list of instructions 5 bytes long, and a start af 100, you get back
an array of five elements that should correspond to memory addresses 100-104.</p>

<p>The reason we need the end address is that we're going to fill gaps with zeroes, which
correspond to nops. So, the whole code generation process:</p>

<ul>
    <li>Make an array of zeroes, indexed from 0 to (end-start-1)</li>
    <li>Go through the list of instructions, generating code for them:</li>
    <li>.db instructions turn into byte values starting at <code>line.address - start</code></li>
    <li>Opcodes turn into instruction bytes at <code>line.address - start</code> followed (maybe) by
    arguments.</li>
    <li>Any other directive is skipped (even .orgs, we already have the addresses calculated)</li>
</ul>

<p>The instruction bytes are formed of six bits defining the instruction followed by two
bits denoting how many bytes of argument follow it. We know how long the argument is
because of <code>line.length</code> and we know which instruction it is because of <code>line.opcode</code>.</p>

<p>Vulcan is a little-endian architecture: multi-byte arguments / .dbs will store the
least-significant byte at the lowest address, then the more significant bytes following.</p>


</td>
<td class="code">
  <div class="highlight"><pre><span class="k">function</span> <span class="nf">generate_code</span>(lines, start_addr, end_addr)
    <span class="k">local</span> mem = {}

    <span class="k">for</span> a = 0, (end_addr - start_addr - 1) <span class="k">do</span>
        mem[a] = 0
    <span class="k">end</span>

    <span class="k">for</span> _, line <span class="k">in</span> <span class="nt">ipairs</span>(lines) <span class="k">do</span>
        <span class="k">if</span> line.directive == <span class="s">'.db'</span> <span class="k">then</span>
            <span class="k">if</span> <span class="nt">type</span>(line.argument) == <span class="s">'table'</span> <span class="k">then</span>
                <span class="k">local</span> a = line.address - start_addr
                <span class="k">for</span> i = 1, #line.argument <span class="k">do</span>
                    mem[a] = line.argument[i]
                    a = a + 1
                <span class="k">end</span>
            <span class="k">else</span>
                mem[line.address - start_addr] = line.argument &amp; 0xff
                mem[line.address - start_addr + 1] = (line.argument &gt;&gt; 8) &amp; 0xff
                mem[line.address - start_addr + 2] = (line.argument &gt;&gt; 16) &amp; 0xff
            <span class="k">end</span>
        <span class="k">elseif</span> line.opcode <span class="k">then</span>
            <span class="k">local</span> opcode_values = {
                push = 0,
                nop = 0,
                add = 1,
                sub = 2,
                mul = 3,
                div = 4,
                mod = 5,
                rand = 6,
                [<span class="s">'and'</span>] = 7,
                [<span class="s">'or'</span>] = 8,
                xor = 9,
                [<span class="s">'not'</span>] = 10,
                lshift = 11,
                rshift = 12,
                arshift = 13,
                pop = 14,
                dup = 15,
                [<span class="s">'2dup'</span>] = 16,
                swap = 17,
                pick = 18,
                height = 19,
                jmp = 20,
                jmpr = 21,
                call = 22,
                ret = 23,
                brz = 24,
                brnz = 25,
                brgt = 26,
                brlt = 27,
                hlt = 28,
                <span class="nt">load</span> = 29,
                <span class="nt">load</span>16 = 30,
                <span class="nt">load</span>24 = 31,
                store = 32,
                store16 = 33,
                store24 = 34,
                inton = 35,
                intoff = 36,
                setiv = 37,
                frame = 38,
                [<span class="s">'local'</span>] = 39,
                setlocal = 40
            }

            <span class="k">local</span> instruction = opcode_values[line.opcode] <span class="o">or</span> <span class="nt">error</span>(<span class="s">'Unrecognized opcode on line '</span> .. line.line .. <span class="s">': '</span> .. line.opcode)

            instruction = (instruction &lt;&lt; 2) + (line.length - 1)
            mem[line.address - start_addr] = instruction
            <span class="k">if</span> line.length &gt; 1 <span class="k">then</span> mem[line.address - start_addr + 1] = line.argument &amp; 0xff <span class="k">end</span>
            <span class="k">if</span> line.length &gt; 2 <span class="k">then</span> mem[line.address - start_addr + 2] = (line.argument &gt;&gt; 8) &amp; 0xff <span class="k">end</span>
            <span class="k">if</span> line.length &gt; 3 <span class="k">then</span> mem[line.address - start_addr + 3] = (line.argument &gt;&gt; 16) &amp; 0xff <span class="k">end</span>
        <span class="k">end</span>
    <span class="k">end</span>

    <span class="k">return</span> mem
<span class="k">end</span>
</pre></div>
</td>
</tr><tr id="section-31">
<td class="docs">
  <div class="pilwrap">
    <a class="pilcrow" href="#section-31">&#182;</a>
  </div>
  
<h2>Assemble function</h2>
<p>Bring everything else together to go from an iterator on lines of code, to a final array
of bytes ready to be written to something (or interpreted by a CPU)</p>


</td>
<td class="code">
  <div class="highlight"><pre><span class="k">function</span> <span class="nf">assemble</span>(iterator)
    <span class="k">local</span> lines = parse_assembly(iterator)
    <span class="k">local</span> symbols = solve_equs(lines)
    measure_instructions(lines, symbols)
    place_labels(lines, symbols)
    calculate_args(lines, symbols)
    <span class="k">return</span> generate_code(lines, symbols[<span class="s">'$start'</span>], symbols[<span class="s">'$end'</span>]), symbols[<span class="s">'$start'</span>]
<span class="k">end</span>

<span class="k">return</span> {
    statement=statement,
    parse_assembly=parse_assembly,
    evaluate=evaluate,
    solve_equs=solve_equs,
    measure_instructions=measure_instructions,
    place_labels=place_labels,
    calculate_args=calculate_args,
    assemble=assemble
}
</pre></div>
</td>
</tr></tbody>
    </table>
  </div>
</body>
</html>